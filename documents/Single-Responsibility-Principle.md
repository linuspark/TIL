
>한 클래스는 단 한 가지의 변경 이유만을 가져야 한다. 
>A class should have only one reason to change.

# 책임이란 무엇인가?

책임(Resposibility)을 '변경할 이유(reason of change)' 오 정의한다.

한 클래스의 변경할 이유를 한 가지 이상 찾을 수 있다면 그 클래스는 한 가지 이상의 책임을 가지고 있다는 것을 의미한다.

하지만 '변경할 이유' 라는 것은 조금 모호한 느낌이 든다. 어떻게든 변경할 이유를 찾고자 한다면 변경할 이유를 찾을 수 있을 것 같고 그렇게 클래스를 나누게 되면 클래스는 결국 아주 작은 단위로 불필요하게 쪼개질 수 있기 때문이다.

예를들어 네트워크로 특정 장비를 제어하는 클래스가 있다고 가정하면 다음과 같이 인터페이스를 구성할 수 있다.

```csharp
public interface Device {
	void Connect(string ip);
	void Close();
	void SendCommand(string msg);
	string ReceiveMessage();
}

```

위 인터페이스로 구성된 클래스는 타당하다. 장비를 제어하기 위해 장비의 ip로 연결하고 장비를 제어하기 위한 커맨드를 전송한 뒤 연결을 해제한다. 하지만 여기서 책임을 나누자면 2가지의 책임을 나누어 볼 수 있다. "연결관리"의 책임과 "데이터 통신" 의 책임이다.

만약, 이 장비로 연결하는 방식이 네트워크 통신에서 시리얼 통신으로 바뀐다면 이 클래스는 변경되어야 한다. (책임 1)

만약, 이 장비에 보내는 커맨드 프로토콜이 바뀐다면 이 클래스는 변경되어야 한다.(책임 2)

```csharp
public interface Connection {
	void Connect(string ip);
	void Close();
}
public interface DataChannel {
	void SendCommand(string msg);
	string ReceiveMessage();
}

```

하지만 반대로 위와 같은 변경사항(요청) 이 없는데 위 클래스를 책임에 따라 두 클래스로 분리한다는 것은 불필요하게 소프트웨어를 복잡하게 만드는 것이다.

여기서 중요한 점은 **변경은 실제로 변경이 일어날 때에만 "변경"이라고 이야기 할 수 있는 것**이다. 아무런 문제가 없는데 이 클래스에 SRP를 적용하거나 다른 원칙들을 적용하는 것은 현명하지 못 한 방식이다.

# 책임 분리하기

위의 예시대로 결합된 책임을 분리하여 장비를 제어하는 클래스를 만들면 다음과 같이 구현할 수 있다.

```java
public class DeviceImplimentation: Connection, DataChannel {
...
}

```

이런 구현은 인터페이스로 분리된 두 책임을 다시 결합한다. DeviceImplimentation 이라는 클래스는 아직 "연결관리" 책임과 "데이터 통신"에 대한 책임 둘 다 가지고 있다.

이런 구현은 하드웨어(장비)를 제어한다는 이유로 인해 책임을 결합해 둔 것이다. 하지만 인터페이스는 분리하여 애플리케이션의 나머지 부분에 한하여 개념을 분리하였다.

DeviceImplimentation 과 같이 구현하는 것이 아니라 Connection과 Data Channel을 따로 클래스로 구현하여 개별 책임 만을 가지도록 하는 것이 더 좋다고 생각할 수도 있다. 하지만 이 클래스를 보면 DeviceImplimentation에서 모든 의존성 흐름이 나가고 있다. 즉, 아무것도 이 클래스에 의존하고 있는 것이 없다. 따라서 main 이외에는 이 클래스가 있다는 사실을 알 필요가 없다. 이렇게 하여 애플리케이션의 나머지 부분을 오염시킬 필요가 없도록 한 것이다.

모든 의존성은 필요악 일 수 있는 것이다.

# 결론

SRP는 가장 간단한 원칙으로 보이지만 가장 지키기 어려운 원칙이다.

어떤 책임이 존재하고 이런 책임을 이런 저런 이유로 묶어버리는 것은 너무나 자연스럽기 때문이다.

----------

참고. 로버트C마틴. 클린 소프트웨어 애자일 원칙과 패턴 그리고 실천 방법 (이용원, 김정민, 정지호 옮김)
