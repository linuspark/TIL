# 비트연산

## 논리 연산

- AND : &
- OR : |
- XOR : ^
- 비트보수 : ~

## 시프트 연산

### 논리 시프트

모든 비트를 이동시킨다. 단순히 주어진 수 만큼의 비트를 이동시키고 비어 있는 비트 위치를 0 으로 채운다.

### 산술 시프트

부호 비트를 고려하여 비트를 이동시킨다. 

비트의 이동이 양수일 경우에는 논리 시프트와 다를 바 없다.

음수일 경우에는 부호 비트를 고려하여 비어있는 비트 위치를 1로 채운다.

![https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Rotate_right_arithmetically.svg/600px-Rotate_right_arithmetically.svg.png](https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Rotate_right_arithmetically.svg/600px-Rotate_right_arithmetically.svg.png)
# 2의 보수와 음수

컴퓨터에서는 정수를 저장할 때 2의 [보수](https://ko.wikipedia.org/wiki/%EB%B3%B4%EC%88%98_(%EC%88%98%ED%95%99)) 형태로 저장을 한다. 

숫자를 표현하기 위한 첫 비트를 부호비트로 하고 나머지 비트로 숫자를 표현하는 형태로,  N비트로 표현되는 숫자에 대한 2의 보수는 $2^N$에 대한 보숫값과 같다.

부호비트는 양수일 경우 0, 음수일 경우 1로 설정된다.

예를 들어 4 비트로 표현되는 정수 -3은 다음과 같이 구할 수 있다. 

**1101 *(2진수)*** = -3 

- 1 = 음수를 의미
- 101 (2진수) = |-3| 의 8에 대한 보수는 5(= 0b101)

2의 보수를 표현하는 다른 방법은 양수로 표현된 2진수를 비트 반전 시킨 뒤에 1을 더해주는 것이다.

같은 예시로 4비트로 표현되는 정수 -3을 구하면

1. 양수표현 : 3 = **0b0011**
2. 비트반전 : **0b1100**
3. 1 더함 : **0b1101**

즉 4 비트로 표현하는 정수는 다음과 같이 표현된다

|정수|비트|정수|비트|
|---|---|---|---|
|1|0001|-1|1111|
|2|0010|-2|1110|
|3|0011|-3|1101|
|4|0100|-4|1100|
|5|0101|-5|1011|
|6|0110|-6|1010|
|7|0111|-7|1001|
|0|0001|||

# 부동 소수점

컴퓨터에서 실수를 표현하는 방식. [IEEE754](https://ko.wikipedia.org/wiki/IEEE_754)를 따른다. 대칭되는 말로는 고정 소수점이 있다.

C#의 경우에는 float, double, decimal 과 같은 [부동소수점 숫자 형식](https://docs.microsoft.com/ko-kr/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)을 지원한다. 이러한 부동 소수점은 비교연산을 수행할 때 주의해야 한다. 상식적으로 이해되지 않는 0.1 + 0.2 == 0.3 이 거짓이 되는 경우와 같은 경우가 발생할 수 있기 때문이다. 이런 오차는 "부동 소수점" 이라는 특성 때문에 발생한다.

## 이진기수법

컴퓨터에서 데이터는 2진법으로 저장되는 것은 당연하다. 10진수 정수를 2진법으로 표현하는 것은 많이 접해 보았다. 이 때 실수의 경우에도 2진법으로 변환이 가능해야 한다.

소수 부분을 2진법으로 변환하는 것은 정수 부분의 반대로 생각하면 된다. 정수의 경우에는 2의 제곱수들의 조합으로 숫자를 표현한다. ($13 =8+4+1 2^3 + 2^2 + 2^0 = 1101_{(2)}$) 소수의 경우에는 2의 음의 제곱수 들의 조합으로 숫자를 표현할 수 있다. ($0.625 = 0.5 + 0.125  = 2^{-1} + 2^{-3} = 0.101_{(2)}$

## 고정 소수점(Fixed Point)

부동 소수점을 이해하기 전에 고정 소수점(fixed point) 을 먼저 보면 고정 소수점은 이해하기가 쉽다.

소숫점 윗 부분(정수부)과 소숫점 아랫 부분(소수부)을 따로 저장하는 방식이다. 예를들어 123.625 이라는 소수는 123과 625 을 따로 저장하고 있는 방식이다.

32 비트 저장 공간을 예로 들면, 첫 1 비트 는 부호, 다음 15 비트는 **정수부**, 다음 16 비트는 소수부를 저장하는 방식이다. 

123.625 = 0b 0 0000000 01111011 10100000 00000000

직관적이고 사용하기 편하지만 고정 소수점의 단점은 표현할 수 있는 숫자 범위가 제한적이라는 점이다. 이런 문제를 해결하기 위해 부동 소수점 방식이 고안되었다

## 부동 소수점(Floating Point)

부동 소수점은 정수부/소수부 를 나누는 것이 아니라 가수부/지수부를 나누어 표기한다. 이 때 정수부 가수부의 수식은 다음과 같다.

$\pm(1.가수부)\times2^{지수부-127}$

![https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/General_floating_point_ko.svg/500px-General_floating_point_ko.svg.png](https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/General_floating_point_ko.svg/500px-General_floating_point_ko.svg.png)

이는 2진수를 그대로 저장하는 것이 아니라 정규화(Normalization) 과정을 거쳐서 저장하는 것을 의미한다. 이 때 2진수의 정규화는 $1.aaa \times 2^n$ 의 형태로 변환하는 것을 말한다.

2진 기수법으로 표기된 숫자를 정규화 하는 것은 간단하다. 정수부에 1 만 남을 때 까지 소숫점을 이동시키고 이동시킨 소숫점 만큼 n을 설정하면 된다. 즉, 123.625 = 1111011.101 의 경우 정규화 하면 소숫점을 6번 이동시키고 $1.111011101 \times 2^{6}$ 가 된다.

이 때 지수부에는 bias 값을 더해주어야 한다. 32 비트 저장공간의 경우 지수부의 bias값은 127이 된다. 따라서 123.625 의 경우 32 비트 저장공간에 부동 소수점으로 저장할 경우 다음과 같이 저장된다.

123.625 = 0b 0 10000101 11101110100000000000000

---

참고. 게일 라크만 맥도웰. 코딩 인터뷰 완전분석 (이창현 옮김)

참고. "부동소수점", Wikipedia